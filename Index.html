<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Follow Me: Ultimate Diagnostic</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        body { background-color: #000; color: #e5e5e5; touch-action: none; overscroll-behavior: none; font-family: monospace; overflow: hidden; display: flex; flex-direction: column; height: 100vh; }
        
        /* HUD */
        #hud { height: 100px; background: #0a0a0a; border-bottom: 1px solid #333; display: flex; flex-direction: column; justify-content: center; padding: 0 1rem; z-index: 20; }
        .hud-row { display: flex; justify-content: space-between; align-items: center; width: 100%; margin-bottom: 5px; }
        #progress-bg { height: 6px; background: #222; width: 100%; border-radius: 3px; overflow: hidden; }
        #progress-fill { height: 100%; background: #3b82f6; width: 0%; transition: width 0.2s; }
        
        #target-name { font-size: 1.4rem; font-weight: 900; color: #fff; text-transform: uppercase; letter-spacing: 1px; text-align: center; }
        #attempts-display { font-size: 0.8rem; color: #666; font-weight: bold; }
        .fail-dot { display: inline-block; width: 8px; height: 8px; background: #333; border-radius: 50%; margin-left: 2px; }
        .fail-dot.active { background: #ef4444; }

        /* PAD */
        #gesture-pad { flex-grow: 1; position: relative; border: 2px dashed #333; background: rgba(20, 20, 20, 0.5); margin: 10px; border-radius: 12px; display: flex; align-items: center; justify-content: center; }
        #feedback { font-size: 2rem; font-weight: 900; color: rgba(255,255,255,0.1); pointer-events: none; white-space: nowrap; text-align: center; }

        /* LOGS */
        #log-window { position: fixed; bottom: 70px; left: 10px; right: 10px; height: 100px; background: rgba(0,0,0,0.85); color: #0f0; font-size: 10px; overflow-y: auto; padding: 8px; border: 1px solid #333; border-radius: 8px; pointer-events: none; opacity: 0.8; }
        
        /* CONTROLS */
        #controls { height: 60px; background: #0a0a0a; border-top: 1px solid #333; display: flex; align-items: center; justify-content: center; gap: 1rem; z-index: 20; }
        button { padding: 10px 20px; border-radius: 6px; font-weight: bold; text-transform: uppercase; font-size: 0.85rem; cursor: pointer; border: 1px solid #444; background: #222; color: #fff; }
        button.primary { background: #2563eb; border-color: #1d4ed8; }
        button.danger { background: #7f1d1d; border-color: #991b1b; color: #fca5a5; }

        .flash-success { animation: flashGreen 0.3s ease-out; }
        .flash-fail { animation: flashRed 0.3s ease-out; }
        @keyframes flashGreen { 0% { background: rgba(0,255,0,0.3); } 100% { background: rgba(20,20,20,0.5); } }
        @keyframes flashRed { 0% { background: rgba(255,0,0,0.3); } 100% { background: rgba(20,20,20,0.5); } }
    </style>
</head>
<body>

    <div id="hud">
        <div class="hud-row">
            <span id="counter" class="text-xs text-gray-500 font-mono">0 / 0</span>
            <div id="attempts-display">
                <span class="fail-dot" id="dot-1"></span>
                <span class="fail-dot" id="dot-2"></span>
                <span class="fail-dot" id="dot-3"></span>
                <span class="fail-dot" id="dot-4"></span>
                <span class="fail-dot" id="dot-5"></span>
            </div>
        </div>
        <div id="target-name">INITIALIZING</div>
        <div id="progress-bg"><div id="progress-fill"></div></div>
    </div>

    <div id="gesture-pad">
        <div id="feedback">READY</div>
    </div>

    <div id="log-window"></div>

    <div id="controls">
        <button class="danger" onclick="resetTest()">Restart</button>
        <button class="primary" id="btn-copy" onclick="copyReport()" style="display:none">ðŸ“„ Copy Report</button>
    </div>

    <script>
        // --- LOGGING ---
        const logWin = document.getElementById('log-window');
        function log(msg, color='#fff') {
            const div = document.createElement('div');
            div.textContent = `> ${msg}`;
            div.style.color = color;
            logWin.appendChild(div);
            logWin.scrollTop = logWin.scrollHeight;
        }

        // --- GESTURE ENGINE v81 (Embedded) ---
        class GestureEngine {
            constructor(targetElement, config, callbacks) {
                this.target = targetElement || document.body;
                this.config = Object.assign({
                    tapDelay: 300,        
                    longPressTime: 500,   
                    swipeThreshold: 30,   
                    spatialThreshold: 10, 
                    tapPrecision: 30,
                    longSwipeThreshold: 250, // INCREASED to prevent accidental long swipes
                    multiSwipeThreshold: 10, // LOWERED for easier 2-finger swipes
                    debug: false
                }, config || {});

                this.callbacks = Object.assign({
                    onGesture: (data) => console.log('Gesture:', data), 
                    onContinuous: (data) => {}
                }, callbacks || {});

                this.allowedGestures = new Set(); 
                this.activePointers = {};
                this.history = [];
                this.tapStack = { count: 0, fingers: 0, timer: null, history: [], active: false };
                this.debounceTimer = null;
                this.staleCheckTimer = null;

                this.contState = {
                    rotStartAngle: 0, rotAccumulator: 0, rotLastUpdate: 0, pinchStartDist: 0,
                    squiggle: { isTracking: false, startX: 0, lastX: 0, direction: 0, flips: 0, hasTriggered: false },
                    squiggle2F: { isTracking: false, lastX: 0, direction: 0, flips: 0, hasTriggered: false }
                };

                this._bindHandlers();
                this._startStaleCheck();
            }

            _bindHandlers() {
                const t = this.target;
                t.addEventListener('pointerdown', e => this._handleDown(e), { passive: false });
                t.addEventListener('pointermove', e => this._handleMove(e), { passive: false });
                t.addEventListener('pointerup', e => this._handleUp(e), { passive: false });
                t.addEventListener('pointercancel', e => this._forceReset(e), { passive: false });
                t.addEventListener('contextmenu', e => e.preventDefault());
            }

            _startStaleCheck() {
                this.staleCheckTimer = setInterval(() => {
                    const now = Date.now();
                    let cleared = false;
                    Object.keys(this.activePointers).forEach(key => {
                        if (now - this.activePointers[key].startTime > 2000) {
                            delete this.activePointers[key];
                            cleared = true;
                        }
                    });
                    if (cleared && Object.keys(this.activePointers).length === 0) {
                        this._resetContinuous();
                    }
                }, 1000);
            }

            _forceReset(e) {
                if (e && this.activePointers[e.pointerId]) delete this.activePointers[e.pointerId];
                if (Object.keys(this.activePointers).length === 0) {
                    this._resetContinuous();
                    this.history = [];
                }
            }

            _resetContinuous() {
                this.contState.pinchStartDist = 0;
                this.contState.squiggle.isTracking = false;
                this.contState.squiggle2F.isTracking = false;
                this.contState.squiggle.hasTriggered = false;
                this.contState.squiggle2F.hasTriggered = false;
            }

            _handleDown(e) {
                if (e.target.tagName === 'BUTTON') return;
                this.activePointers[e.pointerId] = {
                    id: e.pointerId,
                    pts: [{ x: e.clientX, y: e.clientY }],
                    startTime: Date.now()
                };
                const count = Object.keys(this.activePointers).length;
                const pointers = Object.values(this.activePointers);
                if (count === 1) {
                    this.contState.squiggle = {
                        isTracking: true, startX: e.clientX, lastX: e.clientX, direction: 0, flips: 0, hasTriggered: false
                    };
                }
            }

            _handleMove(e) {
                if (!this.activePointers[e.pointerId]) return;
                const ptr = this.activePointers[e.pointerId];
                ptr.pts.push({ x: e.clientX, y: e.clientY });
            }

            _handleUp(e) {
                if (!this.activePointers[e.pointerId]) return;
                this.activePointers[e.pointerId].endTime = Date.now();
                this.history.push(this.activePointers[e.pointerId]);
                delete this.activePointers[e.pointerId];
                const remaining = Object.keys(this.activePointers).length;
                if (remaining === 0) {
                    this._resetContinuous();
                    clearTimeout(this.debounceTimer);
                    this.debounceTimer = setTimeout(() => this._analyze(), 50);
                }
            }

            _analyze() {
                const inputs = this.history; this.history = [];
                if (inputs.length === 0) return;
                const fingers = new Set(inputs.map(s => s.id)).size;
                
                let sc = {x:0,y:0}, ec = {x:0,y:0};
                let startTime = Infinity, endTime = -Infinity;
                inputs.forEach(s => {
                    sc.x += s.pts[0].x; sc.y += s.pts[0].y;
                    ec.x += s.pts[s.pts.length-1].x; ec.y += s.pts[s.pts.length-1].y;
                    if(s.startTime < startTime) startTime = s.startTime;
                    if(s.endTime > endTime) endTime = s.endTime;
                });
                sc.x /= inputs.length; sc.y /= inputs.length;
                ec.x /= inputs.length; ec.y /= inputs.length;

                const duration = endTime - startTime;
                const primaryPath = inputs[0].pts;
                const segments = this._segmentPath(primaryPath);
                const netDist = Math.hypot(ec.x - sc.x, ec.y - sc.y);
                const pathLen = this._getPathLen(primaryPath);
                const isClosed = netDist < 50;
                
                // 1. Long Tap Priority
                if (duration > this.config.longPressTime && netDist < this.config.tapPrecision) {
                    let base = 'long_tap';
                    if (fingers > 1) base += `_${fingers}f`;
                    this._emitGesture(base, fingers, { dir: 'none' });
                    return;
                }

                let turnSum = 0;
                if (segments.length > 1) {
                    for (let i = 0; i < segments.length - 1; i++) {
                        turnSum += this._getTurnDir(segments[i].vec, segments[i + 1].vec);
                    }
                }
                const winding = turnSum > 0 ? 'cw' : 'ccw';
                const startDir = segments[0] ? segments[0].dir : 'none';

                let type = 'tap';
                let meta = { fingers: fingers, dir: startDir, winding: winding };

                // 2. Hybrid Gestures
                if (fingers === 2 && pathLen > 40 && netDist > 40) {
                     let startSpan = 0, endSpan = 0;
                     inputs.forEach(s => {
                         const f = s.pts[0], l = s.pts[s.pts.length-1];
                         startSpan += Math.hypot(f.x - sc.x, f.y - sc.y);
                         endSpan += Math.hypot(l.x - ec.x, l.y - ec.y);
                     });
                     startSpan /= 2; endSpan /= 2;
                     if (Math.abs(endSpan - startSpan) > 30) {
                         const dir = this._getDirection(ec.x - sc.x, ec.y - sc.y);
                         if (endSpan < startSpan * 0.7) { type = 'pinch_swipe'; meta.dir = dir; }
                         else if (endSpan > startSpan * 1.3) { type = 'expand_swipe'; meta.dir = dir; }
                         this._emitGesture(type, fingers, meta);
                         return;
                     }
                }

                // 3. One Finger Logic
                if (fingers === 1) {
                    let shapeDetected = false;
                    if (pathLen > this.config.swipeThreshold) {
                        if (segments.length >= 3) {
                            const a1 = this._getAngleDiff(segments[0].vec, segments[1].vec);
                            const a2 = this._getAngleDiff(segments[1].vec, segments[2].vec);
                            if (Math.abs(a1) > 140 && Math.abs(a2) > 140) { type = 'zigzag'; shapeDetected = true; }
                        }
                        if (!shapeDetected) {
                            if (segments.length >= 4 && isClosed) { type = 'square'; shapeDetected = true; }
                            else if (segments.length === 3 && isClosed) { type = 'triangle'; shapeDetected = true; }
                            else if (segments.length === 3 && !isClosed) { type = 'u_shape'; shapeDetected = true; }
                            else if (segments.length === 2) {
                                const angle = this._getAngleDiff(segments[0].vec, segments[1].vec);
                                if (Math.abs(angle) > 150) type = 'boomerang'; else type = 'corner';
                                shapeDetected = true;
                            }
                        }
                    }

                    if (!shapeDetected) {
                        if (netDist > this.config.longSwipeThreshold) { 
                            type = 'swipe_long'; 
                            meta.dir = this._getDirection(ec.x - sc.x, ec.y - sc.y); 
                        } 
                        else if (netDist > this.config.swipeThreshold) { 
                            type = 'swipe'; 
                            meta.dir = this._getDirection(ec.x - sc.x, ec.y - sc.y); 
                        } 
                        else if (netDist > this.config.spatialThreshold) { 
                            type = 'spatial_tap'; 
                            meta.dir = this._getDirection(ec.x - sc.x, ec.y - sc.y); 
                        }
                    } else if (pathLen < 150) {
                        type = 'motion_tap_' + type;
                    }
                } 

                // 4. Multi Finger Swipes
                if (fingers > 1 && type === 'tap' && netDist > this.config.multiSwipeThreshold) {
                    type = 'swipe';
                    if (segments.length >= 2) {
                         const angle = this._getAngleDiff(segments[0].vec, segments[1].vec);
                         if (Math.abs(angle) > 150) type = 'boomerang';
                    }
                    meta.dir = this._getDirection(ec.x - sc.x, ec.y - sc.y);
                }

                // 5. Tap Logic
                if (type === 'tap') {
                    if (fingers > 1) meta.align = this._getAlignment(inputs);
                    this._handleTapStack(ec, fingers, meta);
                    return;
                }

                this._emitGesture(type, fingers, meta);
            }

            _handleTapStack(pos, fingers, meta) {
                if (this.tapStack.active) {
                    clearTimeout(this.tapStack.timer);
                    if (fingers === this.tapStack.fingers) {
                        this.tapStack.count++;
                        this.tapStack.history.push(pos);
                        this.tapStack.active = true;
                        this.tapStack.timer = setTimeout(() => this._commitStack(), this.config.tapDelay);
                        return;
                    }
                    this._commitStack();
                }
                this.tapStack = {
                    active: true, count: 1, fingers: fingers, history: [pos], align: meta.align,
                    timer: setTimeout(() => this._commitStack(), this.config.tapDelay)
                };
            }

            _commitStack() {
                const { count, fingers, history, align } = this.tapStack;
                if (count === 0) return;
                this.tapStack = { active: false, count: 0, fingers: 0, history: [], timer: null };

                if (count === 1) {
                    let type = 'tap';
                    if (fingers > 1) type += `_${fingers}f`;
                    this._emitGesture(type, fingers, { align });
                } else if (count === 2) {
                    let type = 'double_tap';
                    if (fingers > 1) type += `_${fingers}f`;
                    this._emitGesture(type, fingers, { align }); 
                } else if (count === 3) {
                    let type = 'triple_tap';
                    if (fingers > 1) type += `_${fingers}f`;
                    this._emitGesture(type, fingers, { align });
                }
            }

            // SMART EMITTER (v81 Logic)
            _emitGesture(baseType, fingers, meta, overrideName = null) {
                let id = baseType;

                if (meta && meta.dir && meta.dir !== 'none') {
                    const dir = meta.dir.toLowerCase();
                    const directionalTypes = ['swipe', 'swipe_long', 'spatial_tap', 'square', 'triangle', 'u_shape', 'corner', 'motion_tap_corner', 'triple_tap_corner', 'triple_tap_long', 'triple_tap_boomerang', 'double_tap'];
                    
                    if (directionalTypes.some(t => baseType.startsWith(t)) || baseType.includes('double_tap')) {
                        if (!id.includes(dir)) id += `_${dir}`;
                    }
                }

                // FIXED: Only append winding for SHAPES
                const windingShapes = ['corner', 'triangle', 'u_shape', 'square', 'triple_tap_corner', 'motion_tap_corner', 'boomerang'];
                if (meta && meta.winding && windingShapes.some(s => baseType.includes(s))) {
                    id += `_${meta.winding}`;
                }

                if (fingers > 1 && !id.includes(`${fingers}f`) && !baseType.includes(`${fingers}f`)) id += `_${fingers}f`;
                
                if (meta && meta.align) {
                    const map = { 'Vertical': 'vertical', 'Horizontal': 'horizontal', 'Diagonal SE': 'diagonal_se', 'Diagonal SW': 'diagonal_sw' };
                    if (map[meta.align]) id += `_${map[meta.align]}`;
                }

                const multiFingerBases = ['tap_2f', 'double_tap_2f', 'triple_tap_2f', 'long_tap_2f', 'tap_3f', 'double_tap_3f', 'triple_tap_3f', 'long_tap_3f'];
                if (multiFingerBases.includes(id)) id += '_any';

                this.callbacks.onGesture({ id: id, base: baseType, fingers: fingers, meta: meta, name: id });
            }

            // UTILS
            _getRotationAngle(p1, p2) { return Math.atan2(p2.y - p1.y, p2.x - p1.x) * 180 / Math.PI; }
            _segmentPath(pts) {
                if (pts.length < 5) return [{dir: 'none', vec:{x:0,y:0}}];
                const segments = []; let start = 0; const threshold = 60; 
                for (let i = 5; i < pts.length - 5; i+=3) {
                    const dx1 = pts[i].x - pts[start].x; const dy1 = pts[i].y - pts[start].y;
                    const dx2 = pts[i+5].x - pts[i].x; const dy2 = pts[i+5].y - pts[i].y;
                    const a1 = Math.atan2(dy1, dx1) * 180/Math.PI; const a2 = Math.atan2(dy2, dx2) * 180/Math.PI;
                    let diff = Math.abs(a1-a2); if (diff > 180) diff = 360 - diff;
                    if (diff > threshold && Math.hypot(dx1,dy1) > 20) {
                        segments.push({ dir: this._getDirection(dx1, dy1), vec: {x:dx1, y:dy1} }); start = i;
                    }
                }
                const lastDx = pts[pts.length-1].x - pts[start].x; const lastDy = pts[pts.length-1].y - pts[start].y;
                if (Math.hypot(lastDx, lastDy) > 10) segments.push({ dir: this._getDirection(lastDx, lastDy), vec: {x:lastDx, y:lastDy} });
                return segments;
            }
            _getTurnDir(v1, v2) { return (v1.x * v2.y - v1.y * v2.x); }
            _getAngleDiff(v1, v2) { const a1 = Math.atan2(v1.y, v1.x)*180/Math.PI; const a2 = Math.atan2(v2.y, v2.x)*180/Math.PI; let d = Math.abs(a1-a2); if(d>180) d=360-d; return d; }
            _getPathLen(pts) { let l=0; for(let i=1;i<pts.length;i++) l+=Math.hypot(pts[i].x-pts[i-1].x, pts[i].y-pts[i-1].y); return l; }
            _getDirection(dx, dy) {
                const ang = Math.atan2(dy, dx) * 180 / Math.PI;
                if (ang > -22.5 && ang <= 22.5) return 'right'; 
                if (ang > 22.5 && ang <= 67.5) return 'se';
                if (ang > 67.5 && ang <= 112.5) return 'down'; 
                if (ang > 112.5 && ang <= 157.5) return 'sw';
                if (ang > 157.5 || ang <= -157.5) return 'left'; 
                if (ang > -157.5 && ang <= -112.5) return 'nw';
                if (ang > -112.5 && ang <= -67.5) return 'up'; 
                return 'ne';
            }
            _getAlignment(inputs) {
                if (inputs.length < 2) return null;
                const pts = inputs.map(s => s.pts[0]);
                const xs = pts.map(p => p.x); const ys = pts.map(p => p.y);
                const w = Math.max(...xs) - Math.min(...xs); const h = Math.max(...ys) - Math.min(...ys);
                if (h > w * 1.5) return 'Vertical'; if (w > h * 1.5) return 'Horizontal';
                const left = pts.reduce((a,b) => a.x < b.x ? a : b); const right = pts.reduce((a,b) => a.x > b.x ? a : b);
                return right.y > left.y ? 'Diagonal SE' : 'Diagonal SW';
            }
        }

        // --- GENERATE ALL GESTURES ---
        const ALL_GESTURES = [];
        // 1. Basic Taps
        ALL_GESTURES.push('tap', 'double_tap', 'triple_tap', 'long_tap');

        // 2. Directional Swipes & Taps
        const DIRS = ['up', 'down', 'left', 'right', 'nw', 'ne', 'sw', 'se'];
        DIRS.forEach(d => {
            ALL_GESTURES.push(`swipe_${d}`);
            ALL_GESTURES.push(`swipe_long_${d}`);
            ALL_GESTURES.push(`spatial_tap_${d}`);
        });

        // 3. Multi-Finger Taps (2F & 3F)
        ['2', '3'].forEach(f => {
            ['tap', 'double_tap', 'triple_tap', 'long_tap'].forEach(type => {
                ['vertical', 'horizontal', 'diagonal_se', 'diagonal_sw'].forEach(a => {
                    ALL_GESTURES.push(`${type}_${f}f_${a}`);
                });
            });
        });

        // 4. Multi-Finger Swipes
        ['2', '3'].forEach(f => {
            DIRS.forEach(d => {
                ALL_GESTURES.push(`swipe_${d}_${f}f`);
            });
        });

        // 5. Shapes
        const SHAPES = ['corner', 'triangle', 'square', 'u_shape'];
        SHAPES.forEach(s => {
            ALL_GESTURES.push(`${s}_cw`, `${s}_ccw`);
        });

        // --- RUNTIME ---
        let currentIndex = 0;
        let failCount = 0;
        let results = { passed: [], skipped: [], failures: [] };
        
        const targetName = document.getElementById('target-name');
        const feedback = document.getElementById('feedback');
        const counter = document.getElementById('counter');
        const pad = document.getElementById('gesture-pad');
        const progressFill = document.getElementById('progress-fill');
        const btnCopy = document.getElementById('btn-copy');

        function init() {
            log("Engine Started (v81)");
            new GestureEngine(pad, {
                debug: true,
                longSwipeThreshold: 250,
                multiSwipeThreshold: 10
            }, {
                onGesture: handleGesture
            });
            render();
        }

        function handleGesture(data) {
            if (currentIndex >= ALL_GESTURES.length) return;
            const target = ALL_GESTURES[currentIndex];
            const detected = data.id;

            feedback.textContent = detected;
            feedback.style.opacity = '1';
            
            // LOGIC: Is it a match?
            let match = (detected === target);
            // Relaxed matching for "Any" or "Diagonal" variance
            if (target.endsWith('_any') && detected.startsWith(target.replace('_any', ''))) match = true;
            
            if (match) {
                // PASS
                pad.classList.add('flash-success');
                setTimeout(() => pad.classList.remove('flash-success'), 300);
                log(`PASS: ${target}`, '#4ade80');
                results.passed.push(target);
                next();
            } else {
                // FAIL
                pad.classList.add('flash-fail');
                setTimeout(() => {
                    pad.classList.remove('flash-fail');
                    feedback.style.opacity = '0.2';
                }, 400);
                
                failCount++;
                log(`FAIL (${failCount}/5): Expected ${target}, Got ${detected}`, '#f87171');
                updateDots();

                // Log the failure detail
                results.failures.push({
                    target: target,
                    attempt: failCount,
                    detected: detected
                });

                if (failCount >= 5) {
                    log(`SKIPPING ${target} (Too many fails)`, '#ef4444');
                    results.skipped.push({ target: target, history: results.failures.filter(f => f.target === target) });
                    next();
                }
            }
        }

        function next() {
            currentIndex++;
            failCount = 0;
            if (currentIndex >= ALL_GESTURES.length) finish(); else render();
        }

        function updateDots() {
            for(let i=1; i<=5; i++) {
                const dot = document.getElementById(`dot-${i}`);
                if (i <= failCount) dot.classList.add('active');
                else dot.classList.remove('active');
            }
        }

        function render() {
            if (currentIndex >= ALL_GESTURES.length) return;
            targetName.textContent = ALL_GESTURES[currentIndex].replace(/_/g, ' ');
            counter.textContent = `${currentIndex + 1} / ${ALL_GESTURES.length}`;
            progressFill.style.width = `${(currentIndex / ALL_GESTURES.length) * 100}%`;
            feedback.textContent = "DRAW";
            feedback.style.opacity = '0.1';
            updateDots();
        }

        function finish() {
            targetName.textContent = "COMPLETE";
            feedback.textContent = "DONE";
            progressFill.style.width = '100%';
            btnCopy.style.display = 'block';
            log("Test Complete. Click Copy Report.");
        }

        window.resetTest = function() {
            currentIndex = 0;
            failCount = 0;
            results = { passed: [], skipped: [], failures: [] };
            btnCopy.style.display = 'none';
            log("Restarting...");
            render();
        }

        window.copyReport = function() {
            const report = {
                total: ALL_GESTURES.length,
                passedCount: results.passed.length,
                skippedCount: results.skipped.length,
                skippedDetails: results.skipped
            };
            navigator.clipboard.writeText(JSON.stringify(report, null, 2));
            alert("Report Copied!");
        }

        setTimeout(init, 200);

    </script>
</body>
</html>
