<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Gesture Engine Test Suite</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: #1a1a1a;
            color: #fff;
            font-family: monospace;
            overflow: hidden; /* Prevent scrolling */
            touch-action: none; /* Critical for gesture handling */
            display: flex;
            flex-direction: column;
            height: 100vh;
        }

        #header {
            padding: 15px;
            background: #333;
            text-align: center;
            border-bottom: 1px solid #555;
            flex-shrink: 0;
        }

        #status-bar {
            display: flex;
            justify-content: space-between;
            font-size: 14px;
            margin-bottom: 10px;
            color: #aaa;
        }

        #current-task {
            font-size: 24px;
            font-weight: bold;
            color: #4CAF50;
            margin: 10px 0;
        }

        #instruction {
            font-size: 16px;
            color: #ddd;
        }

        #touch-zone {
            flex-grow: 1;
            display: flex;
            align-items: center;
            justify-content: center;
            position: relative;
            background: #222;
            border: 2px dashed #444;
            margin: 10px;
            border-radius: 8px;
        }

        #touch-zone.success { background: rgba(76, 175, 80, 0.2); border-color: #4CAF50; }
        #touch-zone.fail { background: rgba(244, 67, 54, 0.2); border-color: #f44336; }

        #feedback-log {
            position: absolute;
            bottom: 10px;
            left: 10px;
            right: 10px;
            text-align: center;
            font-size: 14px;
            color: #888;
            pointer-events: none;
        }

        #controls {
            padding: 20px;
            text-align: center;
            background: #333;
            flex-shrink: 0;
        }

        button {
            padding: 10px 20px;
            font-size: 16px;
            background: #2196F3;
            color: white;
            border: none;
            border-radius: 4px;
            cursor: pointer;
        }
        button:disabled { background: #555; }

        /* Results Modal */
        #results-modal {
            display: none;
            position: fixed;
            top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9);
            z-index: 100;
            overflow-y: auto;
            padding: 20px;
            box-sizing: border-box;
        }
        
        .result-row {
            display: flex;
            justify-content: space-between;
            padding: 8px;
            border-bottom: 1px solid #444;
        }
        .pass { color: #4CAF50; }
        .fail { color: #f44336; }
        .skip { color: #FFC107; }

    </style>
</head>
<body>

<div id="header">
    <div id="status-bar">
        <span id="progress">Test: 0/0</span>
        <span id="attempts">Attempts: 0/3</span>
    </div>
    <div id="current-task">Press Start</div>
    <div id="instruction">To begin the test suite</div>
</div>

<div id="touch-zone">
    <div id="feedback-log">Latest: None</div>
</div>

<div id="controls">
    <button id="btn-start" onclick="startTest()">Start Test</button>
    <button id="btn-skip" onclick="skipCurrent()" disabled>Skip</button>
</div>

<div id="results-modal">
    <h2>Test Results</h2>
    <div id="results-content"></div>
    <br>
    <button onclick="closeResults()">Close</button>
    <button onclick="copyResults()">Copy to Clipboard</button>
</div>

<script type="module">
    import { GestureEngine } from './gestures.js';

    let engine;
    let testQueue = [];
    let currentIndex = 0;
    let currentAttempts = 0;
    const MAX_ATTEMPTS = 3;
    let results = [];
    let isTesting = false;

    // --- GENERATE TEST QUEUE ---
    function generateQueue() {
        const q = [];
        const directions = ['up', 'down', 'left', 'right', 'ne', 'nw', 'se', 'sw'];
        const windings = ['cw', 'ccw'];
        
        // 1. Basic Swipes
        directions.forEach(d => q.push({ id: `swipe_${d}`, name: `Swipe ${d.toUpperCase()}` }));
        
        // 2. Long Swipes (Subset to save time, mostly orthogonal)
        ['up', 'down', 'left', 'right'].forEach(d => q.push({ id: `swipe_long_${d}`, name: `Long Swipe ${d.toUpperCase()}` }));

        // 3. Taps & Multi-finger
        q.push({ id: 'tap', name: 'Single Tap' });
        q.push({ id: 'double_tap', name: 'Double Tap' });
        q.push({ id: 'triple_tap', name: 'Triple Tap' });
        q.push({ id: 'long_tap', name: 'Long Tap (Hold >300ms)' });

        // Multi-finger (The engine appends _any for standard 2f/3f taps)
        // We test a representative sample of alignments
        q.push({ id: 'tap_2f_any_vertical', name: '2-Finger Tap (Vertical)' });
        q.push({ id: 'tap_2f_any_horizontal', name: '2-Finger Tap (Horizontal)' });
        q.push({ id: 'tap_3f_any', name: '3-Finger Tap' });

        // 4. Shapes (Testing a subset of directions to keep test under 20 mins)
        // We test one CW and one CCW for each shape type
        q.push({ id: 'corner_cw_ne', name: 'Corner CW (Up -> Right)' });
        q.push({ id: 'corner_ccw_nw', name: 'Corner CCW (Up -> Left)' });
        
        q.push({ id: 'zigzag_right', name: 'ZigZag Right' });
        
        q.push({ id: 'boomerang_cw_right', name: 'Boomerang CW Right (>125Â°)' });
        
        q.push({ id: 'triangle_cw_up', name: 'Triangle CW (Start Up)' });
        q.push({ id: 'square_cw_right', name: 'Square CW' });
        q.push({ id: 'u_shape_cw_up', name: 'U-Shape / Circle' });

        // 5. Spatial Taps (The "Motion Taps")
        // These are 3 distinct taps forming a shape
        q.push({ id: 'triple_tap_spatial_line_right', name: '3-Tap Line (Left -> Mid -> Right)' });
        q.push({ id: 'triple_tap_spatial_corner_ne', name: '3-Tap Corner (Bot-Left -> Top-Left -> Top-Right)' }); 

        // 6. Continuous / Complex
        q.push({ id: 'squiggle_1f', name: 'Squiggle 1-Finger (Shake Back/Forth 4x)' });
        q.push({ id: 'squiggle_2f', name: 'Squiggle 2-Finger (Shake Back/Forth 4x)' });
        q.push({ id: 'pinch', name: 'Pinch (Zoom In/Out)' });
        q.push({ id: 'twist', name: 'Twist (Rotate 2 Fingers)' });

        return q;
    }

    // --- SETUP ENGINE ---
    window.onload = () => {
        const zone = document.getElementById('touch-zone');
        
        engine = new GestureEngine(zone, {
            debug: true,
            swipeThreshold: 40,
            spatialThreshold: 10
        }, {
            onGesture: handleGesture,
            onContinuous: handleContinuous
        });

        // Initialize with ALL allowed so we don't block inputs during testing
        // The engine logic requires an allowed list to be set to function in "strict" mode
        // if logic is updated. Based on your provided code, it checks allowedGestures.
        // We will populate it with our test queue IDs + variations to ensure they trigger.
        const allIDs = generateQueue().map(i => i.id);
        // Add variations to allowed list just in case
        const extras = ['swipe_long_up','swipe_long_down','swipe_long_left','swipe_long_right'];
        engine.updateAllowed([...allIDs, ...extras]);
    };

    function handleGesture(data) {
        if (!isTesting) {
            log(`Detected: ${data.id}`);
            return;
        }
        checkMatch(data.id, data);
    }

    function handleContinuous(data) {
        if (!isTesting) return;
        
        // Continuous gestures come in as { type: 'pinch' } etc.
        // We map them to our IDs
        let detectedId = data.type;
        if (data.type === 'squiggle') detectedId += `_${data.fingers}f`;
        
        log(`Continuous: ${detectedId}`);
        checkMatch(detectedId, data);
    }

    function checkMatch(detectedId, rawData) {
        const target = testQueue[currentIndex];
        
        // Loose matching for complex suffixes if needed
        // E.g., if target is 'tap_2f_any_vertical' and we get 'tap_2f_any_vertical' -> Match
        
        if (detectedId === target.id) {
            flash(true);
            recordResult('Pass', detectedId);
            nextTask();
        } else {
            // Visual feedback for wrong gesture
            log(`Expected: ${target.id} | Got: ${detectedId}`);
            flash(false);
            
            // Increment fail counter handled by logic? 
            // Actually, we count "attempts" as user tries. 
            // Since the engine emits on pointerUp (mostly), every emission is an attempt.
            currentAttempts++;
            updateUI();
            
            if (currentAttempts >= MAX_ATTEMPTS) {
                recordResult('Fail', `Got: ${detectedId}`);
                nextTask();
            }
        }
    }

    function recordResult(status, note) {
        results.push({
            name: testQueue[currentIndex].name,
            id: testQueue[currentIndex].id,
            status: status,
            note: note
        });
    }

    function nextTask() {
        currentIndex++;
        currentAttempts = 0;
        if (currentIndex >= testQueue.length) {
            finishTest();
        } else {
            updateUI();
        }
    }

    window.skipCurrent = function() {
        if (!isTesting) return;
        recordResult('Skip', 'User Skipped');
        nextTask();
    };

    function updateUI() {
        const task = testQueue[currentIndex];
        document.getElementById('current-task').innerText = task.name;
        document.getElementById('instruction').innerText = `Perform: ${task.id}`;
        document.getElementById('progress').innerText = `Test: ${currentIndex + 1}/${testQueue.length}`;
        document.getElementById('attempts').innerText = `Attempts: ${currentAttempts}/${MAX_ATTEMPTS}`;
        document.getElementById('btn-skip').disabled = false;
        document.getElementById('touch-zone').classList.remove('success', 'fail');
    }

    function log(msg) {
        document.getElementById('feedback-log').innerText = msg;
        console.log(msg);
    }

    function flash(success) {
        const z = document.getElementById('touch-zone');
        z.className = success ? 'success' : 'fail';
        setTimeout(() => z.className = '', 300);
    }

    // --- GLOBAL CONTROLS ---
    window.startTest = function() {
        testQueue = generateQueue();
        currentIndex = 0;
        currentAttempts = 0;
        results = [];
        isTesting = true;
        document.getElementById('btn-start').innerText = "Restart Test";
        document.getElementById('results-modal').style.display = 'none';
        
        // Feed the engine the list of allowed gestures so they aren't blocked
        const ids = testQueue.map(t => t.id);
        engine.updateAllowed(ids);
        
        updateUI();
    };

    window.finishTest = function() {
        isTesting = false;
        document.getElementById('current-task').innerText = "Test Complete";
        document.getElementById('instruction').innerText = "See results below";
        document.getElementById('btn-skip').disabled = true;
        showResults();
    };

    window.showResults = function() {
        const modal = document.getElementById('results-modal');
        const content = document.getElementById('results-content');
        modal.style.display = 'block';
        
        let html = '';
        let passCount = 0;
        results.forEach(r => {
            if(r.status === 'Pass') passCount++;
            html += `<div class="result-row">
                <span>${r.name}</span>
                <span class="${r.status.toLowerCase()}">${r.status}</span>
            </div>`;
        });
        
        html = `<h3>Score: ${passCount}/${results.length}</h3>` + html;
        content.innerHTML = html;
    };

    window.closeResults = function() {
        document.getElementById('results-modal').style.display = 'none';
    };
    
    window.copyResults = function() {
        const text = results.map(r => `${r.name}: ${r.status} (${r.note})`).join('\n');
        navigator.clipboard.writeText(text).then(() => alert('Copied!'));
    };
</script>

</body>
</html>
